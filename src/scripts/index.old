/** frontend/pages/HomePage/index.js **
 *
 *
**/

"use strict"

import React, { lazy } from 'react'
import styled, { css } from 'styled-components'
import Config from '../config.json'
import { AI } from './ai.js'
import { shuffle
       , toneColor
       , translucify
       , getRandomFromArray
       , getDifferences
       , getPageXY
       , setTrackedEvents
       , detectMovement
       , intersect
       , union
       , pointWithin
       , valuesMatch
       , replaceAll
       } from './utilities.js'
import { adjusts } from './adjusts.js'
import { Background, Pool } from './audio.js'
import { preload } from './preload.js'
import { Zalgo, zalgo } from './zalgo.js'
import { name } from './name.js'
import { flip } from './flip.js'

import { BACKEND } from '../constants.js';
const Theme = replaceAll(Config, "__BACKEND__", BACKEND)


// console.log(Theme.config)

// Hard-coded value to ensure that rotated square images do not
// extend beyond the edge of the board, either to the left or the
// right, even if the board is slightly reduced to fit a squarish
// screen.
const size = "12.8vmin"
const colors = {
  basic:      Theme.config.colors.backgroundColor
  , tint:     toneColor(Theme.config.colors.backgroundColor, 1.2)
  , darker:   toneColor(Theme.config.colors.backgroundColor, 0.95)
  , shade:    toneColor(Theme.config.colors.backgroundColor, 0.8)
  , winner:   translucify( Theme.config.colors.backgroundColor
                         , Theme.config.colors.opacity / 100)
  , text:      Theme.config.colors.textColor
  , prompt:    translucify(Theme.config.colors.promptColor, 0.6667)
  , disabled:  translucify(Theme.config.colors.textColor, 0.25)

  , menu:      translucify(
                 toneColor( Theme.config.colors.backgroundColor, 1.05)
               , Theme.config.colors.opacity / 100
               )
  , checked:   toneColor(Theme.config.colors.backgroundColor, 1.25)
  , unchecked: toneColor(Theme.config.colors.backgroundColor, 0.9)
  , focus:     toneColor(Theme.config.colors.backgroundColor, 1.333)

  , levels:    translucify(
                 toneColor(Theme.config.colors.backgroundColor, 1.1)
               , .95)
  , level:     translucify(Theme.config.colors.promptColor, 0.5)

  , highlight: toneColor(Theme.config.display.borderColor, 1.25)
  , shadow:    toneColor(Theme.config.display.borderColor, 0.75)
}

const levels = [
  [1,1], [2]
  , [1,2], [3]
  , [1,1,2], [1,3], [4], [1,1,1,1]
  , [1], [1,1,1], [2,2]
  , [2,3], [5], [1,2,2], [1,1,3], [1,1,1,2], [1,4]
  , [1,1,1,3], [1,1,2,2], [2,2,2], [3,3], [1,5], [6], [1,1,4]
    , [2,4], [1,2,3]
  , [2,2,3], [2,5], [1,1,5], [1,1,1,4], [1,6], [1,1,2,3], [1,2,2,2]
    , [3,4], [1,3,3], [7], [1,2,4]
  , [1,7], [2,2,4], [4,4], [1,3,4], [1,1,1,5], [3,5], [1,1,3,3]
    , [1,1,2,4], [2,3,3], [1,2,2,3], [1,2,5]
  , [2,3,4], [1,2,2,4], [1,2,6], [1,4,4], [1,1,1,6], [2,2,5]
    , [1,1,2,5], [1,2,3,3], [1,1,3,4], [4,5], [1,3,5], [3,6]
  , [1,1,3,5], [1,2,7], [2,3,5], [4,6], [1,1,4,4], [3,7], [1,1,2,6]
    , [1,4,5], [1,2,2,5], [1,3,6], [2,4,4], [1,1,1,7], [1,2,3,4]
    , [3,3,4], [5,5]
  , [2,4,5], [3,4,4], [1,3,7], [3,3,5], [1,5,5], [2,2,6], [1,2,4,4]
    , [1,2,2,6], [4,7], [1,1,2,7], [1,3,3,4], [1,1,3,6], [2,3,6]
    , [1,1,4,5], [2,2,7], [1,4,6], [1,2,3,5]
  , [2,4,6], [2,3,7], [1,2,3,6], [2,5,5], [3,3,6], [1,2,2,7], [1,5,6]
    , [3,4,5], [1,2,4,5], [1,1,3,7], [1,3,3,5], [1,1,5,5], [1,1,4,6]
    , [1,3,4,4]
  , [3,4,6], [3,3,7], [1,5,7], [1,1,4,7], [1,3,4,5], [2,5,6]
    , [1,2,3,7], [1,1,5,6], [2,4,7], [1,2,5,5], [3,5,5], [1,3,3,6]
    , [1,2,4,6]
  , [3,4,7], [1,3,3,7], [1,2,4,7], [1,3,4,6], [1,2,5,6], [2,5,7]
    , [1,1,5,7], [1,3,5,5], [3,5,6]
  , [3,5,7], [1,3,4,7], [1,2,5,7], [1,3,5,6]
  , [1,3,5,7]
]
// 133 levels, and a total of 1266 items to remove. Bonus points for
// clicking Play when removing any item would lose.

const ants = (function sanitize(options) {
  if (typeof options !== "object") {
    options = {}
  }

  const defaults = {
    color:   "#fff"
  , length:  10
  , ratio:   5
  , opacity: 0
  , speed:   10
  }

  let temp = options.color
  if ( typeof temp === "string"
     && /#[A-Fa-f0-9]{3,6}$/.test(temp)
     && [0, 4, 7].indexOf(temp.length) > 0
     ) {} else {
    options.color = defaults.color
  }
  const color = options.color

  temp = getNumber(options.length, 1, 200)
  if (temp === false) {
    options.length = defaults.length
  } else {
    options.length = temp
  }
  const length = options.length

  temp = getNumber(options.ratio, 1, 10)
  if (temp === false) {
    options.ratio = defaults.ratio
  } else {
    options.ratio = temp
  }
  const ratio = options.ratio

  const width = options.width = length / ratio

  // An empty string for options.radius gives a curve the same as
  // the rounded end of the dashes. 0 gives a square corner.
  temp = getNumber(options.radius, 0, 100)
  if (temp === false) {
    options.radius = width / 4
  } else {
    options.radius = temp
  }

  temp = getNumber(options.opacity, 0, 1)
  if (temp === false) {
    options.opacity = defaults.opacity
  } else {
    options.opacity = temp
  }

  temp = getNumber(options.speed, 0, 100)
  if (temp === false) {
    options.speed = defaults.speed
  } else {
    options.speed = temp
  }
  const speed = options.speed

  options.dashArray = length * (ratio - 1) / ratio
                    + " "
                    + length * (ratio + 1) / ratio

  options.time = speed ? 10 / speed : 0

  options.dark  = toneColor(color, 0.75)
  options.light = toneColor(color, 1.33)

  return options

  function getNumber(value, min, max) {
    value = parseFloat(value)

    if ( isNaN(value) ) {
      return false
    } else {
      return Math.max(min, Math.min(value, max))
    }
  }
})(Theme.config.select)



function getFontFamily(ff) {
  const start = ff.indexOf('family=');
  if (start === -1) return 'sans-serif';
  let end = ff.indexOf('&', start);
  if(end === -1) end = undefined;
  return ff.slice(start + 7, end).replace("+", " ");
}


const randomPadding = (count, index, top) => {
  if (Theme.config.random.maximize) {
    return "0"
  }

  const getSpacing = (count, index) => {
    switch (count) {
      case 1:
        return 1 // centre

      case 3:
        switch(index) {
          case 0: return 2

          case 1: return 0
          case 2: return 2
        }

      case 5:
        switch (index) {
          case 0: return 2

          case 1: return 0
          case 2: return 2/3
          case 3: return 4/3
          case 4: return 2
        }

      case 7:
        switch (index) {
          case 0: return 2

          case 1: return 0
          case 2: return 2

          case 3: return 0
          case 4: return 2/3
          case 5: return 4/3
          case 6: return 2
        }
    }
  }

  // cell size ≈ 12.8vmin x 22.5vmin (or 25), image size is 2vmin less,
  // leaving at least 11.7vmin of leeway vertically
  const max = 11.7
  const range = Theme.config.random.yAxis
              ? Theme.config.random.yAxis * max / 100
              : 0

  const h = count // calculate spacing based on position
          ? getSpacing(count, index)
          : Theme.config.random.xAxis // calculate spacing randomly
            ? Math.random() * 2
            : 1

  const v = count // padding was calculated earlier: use given top
          ? max / 2 //top
          : range // we haven't calculated padding yet: use range
            ? (Math.random() * range) + (max - range) / 2
            : max / 2
  const padding = `${v}vmin ${h}vmin ${max - v}vmin ${2 - h}vmin`

  return padding
}


const randomRotation = () => {
  const random = Theme.config.random

  // Allow up to ± random-rotation
  const degrees = !random.maximize && random.rotation
                ? Math.random() * random.rotation
                  - random.rotation / 2
                : 0
  const radians = Math.PI * (degrees + 45) / 180
  const length  = Theme.config.display.shadowLength
  const color   = Theme.config.display.shadowColor
  const x = Math.sin(radians) * length
  const y = Math.cos(radians) * length

  return "transform: rotate(" + degrees + "deg);"
       + "filter: drop-shadow("
           +x+"vmin "+y+"vmin "+length+"vmin "+color
       + ");"
}


const Container = styled.div`
  background-color: ${() => Theme.config.colors.backgroundColor};

  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  font-family: '${() => getFontFamily(Theme.config.strings.fontFamily)}', sans-serif;
  color: ${() => Theme.config.colors.textColor};
  text-align: center;

  @media(min-aspect-ratio: 4/3) {
    justify-content: flex-start;
  }
`


const PlayArea = styled.div`
  position: relative;
  height: calc(100vh - 10vmin);
  width: 100vw;
  top: 0;
  display: flex;
  justify-content: center;
  align-items: center;

  & div.background { 
    position: absolute;
    background-image: url(${props => props.background});
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    opacity: ${Theme.config.basic.bgOpacity}
    width: 100%;
    height: 100%;
  }

  @media(max-aspect-ratio: 100/118) {
    align-items: start;
  }

  @media(max-aspect-ratio: 100/121) {
    align-items: center;
  }

  @media(max-aspect-ratio: 20/23) {
    height: calc(100vh - 15vmin);
  }

  @media(min-aspect-ratio: 4/3) {
    height: 100vh;
    width: calc(100vw - 33.333vh);
  }
`


/// BOARD ///

const StyledBoard = styled.div`
  position: relative;


  background-image: url(${Theme.config.basic.background});
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;


  height: calc(100vh - 10vmin);
  width: calc(100vh - 10vmin);
  color: #fff;

  @media(max-aspect-ratio: 20/23) {
    height: 100vw;
    width: 100vw;
  }

  @media(min-aspect-ratio: 4/3) {
    height: 100vh;
    width: 100vh;
  }
`


const StyledRow = styled.div`
  display: flex;
  justify-content: ${Theme.config.basic.alignment};
  align-items: center;
  height: 22.5vmin;

  @media(max-aspect-ratio: 100/118) {
    height: 25vw;
    }
  }

  @media(min-aspect-ratio: 4/3) {
    height: 25vh;
    }
  }
`


const StyledShrinkWrap = styled.div`
  display: inline-block;
  box-sizing: border-box;
  transition: padding ${props =>
    props.groups
   ? Theme.config.menu.groupDuration
   : 0
  }s;
  padding: ${props =>
    props.groups
    ? props.gaps
      ? props.theme.equal
      : props.theme.spacing
    : props.theme.padding
  };
`


const StyledFrame = styled.div`
  ${props => props.children
           ? ""
           : "visibility: hidden;"}

  position: relative;
  display: flex;
  overflow: hidden;
  ${ Theme.config.random.maximize
    ? `width: calc(${size} - 0.2vmin);`
    : `height: calc(${size} - 2vmin);
       width: calc(${size} - 2vmin);`
  }
  background-color: ${Theme.config.display.bgColor};
  border:${Theme.config.display.borderWidth}vmin solid ${colors.shadow};
  border-top-color: ${colors.highlight};
  border-left-color: ${colors.highlight};
  border-radius: ${Theme.config.display.borderRadius}vmin;

  &.group {
    left: 0!important
    transition: left ${Theme.config.menu.groupDuration}s;
  }

  &.selected {
    background-color: ${Theme.config.display.selected};
  }

  &.selected img {
    opacity: ${Theme.config.display.selectOpacity}
  }
`


const StyledImage = styled.img`
  position: relative;
  height: 100%;
  width: 100%;
  cursor: ${props => props.cursor};
  ${props => props.theme.rotation}
`


/// STEP-BY-STEP LEVEL

const StyledLevel = styled.div`
  position: absolute;
  left: 0;
  bottom: 0;
  width: ${props => props.length}%;
  height: 3vmin;
  background-color: ${props => props.color};

  ${props => props.steps ? "" : "display: none;" }
  ${props => props.onMouseDown ? "" : "pointer-events: none;"}

  @media(min-aspect-ratio: 106/110) {
    height: ${props => props.length}vh;
    width: 3vmin;
  }
`


const Level = ({ level, steps, action }) => {
  const ratio = level * 100 / levels.length

  return (
    <div>
      <StyledLevel
        length="100"
        color={colors.levels}
        steps={steps}
        onMouseDown={action}
        onTouchStart={action}
      />
      <StyledLevel
        length={ratio}
        color={colors.level}
        steps={steps}
      />
    </div>
  )
}




/// OVERLAY ///

const StyledOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: calc(100vh - 10vmin);
  width: 100vw;
  pointer-events: none;
  background-color: ${colors.winner};
  font-size: ${Theme.config.strings.fontSize + "vmin"};

  & h1 {
    margin: 0.25em 0 0
  }
  & h2 {
    margin: 0;
    margin-bottom: 0.5em;
    text-decoration: underline
    font-size: 1em
  }
  & h1.ace {
    font-size: ${Theme.config.strings.aceSize}vmin;
    font-style: normal;
  }

  & p {
    margin: 0
  }

  & p:empty {
    height: 0.5em;
  }

  @media(max-aspect-ratio: 20/23) {
    width: 100vw;
  }

  @media(min-aspect-ratio: 4/3) {
    height: 100vh;
    width: calc(100vw - 33vh);
  }

`

class Overlay  extends React.Component {
  constructor(props) {
    super(props)
    this.ref = React.createRef()
    this.decorateText = this.decorateText.bind(this)
  }


  massageText(string, splitHeader) {
    let header
    const array = string.split("\n")
    if (splitHeader) {
      header = array.shift()
    }
    const text = array.map((chunk, index) => {
      const match = /^(.*)\*(.*)\*(.*)$/.exec(chunk)

      if  (match) {
        return <p key={index}>
          {match[1] || ""}
          <strong>{match[2]}</strong>
          {match[3] || ""}
        </p>
      }

      return <p key={index}>{chunk}</p>
    })

    if (splitHeader) {
      return { header, text }
    }

    return text
  }


  decorateText() {
    if (!( this.props.gameState.vsAI
       && !this.props.gameState.noHints
       )) {
      return
    }

    const options = {
      element: this.ref.current   
    , initial: 0
    , duration: 0
    , decay: 10
    , text: this.ref.current.innerText
    }
    new (this.props.TextAnimator)(options)
  }

  render() {
    // console.log("Overlay", props)
    let {
      unlocked
    , showRules
    , winner
    , tips
    , noHints } = this.props.gameState

    let text = ""
    const className = noHints
                    ? "ace"
                    : ""
    const css = {}

    if (!unlocked) {
      // LOADING
      text = <div><img
        src={Theme.config.basic.spinner}
        style={{
          width: "10vmin"
        , height: "10vmin"
        , opacity: 0.5
      }}
      /></div>

    } else if (showRules) {
      // SHOW RULES
      text = this.massageText(Theme.config.strings.rules)

      text = <div>
        <h1>{Theme.config.strings.title}</h1>
        <h2>{Theme.config.strings.slogan}</h2>
        <div>
          {text}
        </div>
      </div>

    } else if (winner) {
      // WINNER
      winner = this.massageText(winner, true)
      text = <div>
        <h1
          ref={this.ref}
          className={className}
        >
          {winner.header}
        </h1>
        {winner.text}
      </div>
      
      setTimeout(this.decorateText, 0)

    } else {
      css.display = "none"
    }

    return (
      <StyledOverlay
        id="Overlay"
        style={css}
      >
        {text}
      </StyledOverlay>
    )
  }
}


/// BUTTONS ///

const StyledButtons = styled.div`
  width: 100%;
  position: fixed;
  bottom: 0;
  display: flex;
  justify-content: space-between;
  pointer-events: none;

  @media(max-aspect-ratio: 20/23) {

  }

  @media(min-aspect-ratio: 4/3) {
    width: auto;
    height: 100vh;
    bottom: auto;
    right: 0;
    flex-direction: column;
    align-items: flex-end;
  }
`


const StyledButton = styled.button`
  width: 33vmin;
  height: 10vmin;
  border-radius: 2vmin;
  font-size: ${Theme.config.strings.buttonSize + "vmin"};
  font-family: '${() => getFontFamily(Theme.config.strings.fontFamily)}', sans-serif;

  background: ${colors.basic};
  border: 0.5vmin solid ${colors.shade};
  border-top-color: ${colors.tint};
  border-left-color: ${colors.tint};
  color: ${colors.text}
  pointer-events: auto;
  cursor: pointer;

  &.pressed {
    background: ${colors.darker};
    border-color: ${colors.tint};
    border-top-color: ${colors.shade};
    border-left-color: ${colors.shade};
  }
  &:disabled {
    border-width: 0.25vmin;
    color: ${colors.disabled};
    cursor: default;
  }
  &.prompt {
    color: ${colors.prompt};
  }
  &:focus {
    outline: none;
  }

  @media(max-aspect-ratio: 20/23) {
    height: 15vmin;
  }

  @media(min-aspect-ratio: 4/3) {
    height: 25vmin;
  }
`


const HiddenCheckbox = styled.input.attrs({ type: 'checkbox' })`
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;

  &:disabled ~ *{
    color: ${colors.disabled};
  }
`


const StyledRulesButton = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: ${Theme.config.strings.buttonSize + "vmin"};
  width: 33vmin;
  height: 10vmin;
  box-sizing: border-box;
  border: 0.5vmin solid
  border-radius: 2vmin;
  border-top-color:    ${props => ( props.checked
                                  ? colors.shade
                                  : colors.tint
                                  )};
  border-left-color:   ${props => ( props.checked
                                  ? colors.shade
                                  : colors.tint
                                  )};
  border-bottom-color: ${props => ( props.checked
                                  ? colors.tint
                                  : colors.shade
                                  )};
  border-right-color:  ${props => ( props.checked
                                  ? colors.tint
                                  : colors.shade
                                  )};
  background:          ${props => ( props.checked
                                  ? colors.darker
                                  : colors.basic
                                  )};
  pointer-events: auto

  @media(max-aspect-ratio: 20/23) {
    height: 15vmin;
  }

  @media(min-aspect-ratio: 4/3) {
    height: 25vmin;
  }
`


const Button = ({ side, gameState, buttonDown }) => {
  const {
    gameOver
  , vsAI
  , player
  , button
  , selected
  , removed
  , hints
  , undo
  , winning
  , unlocked
  } = gameState

  let disabled = !(selected && selected.length)

  const getClassName = () => {
    let className = "unselectable" // always

    if (button) {
      // The player is interacting with one of the buttons...
      if (button.side === side && button.down) {
        // ... and it's this one, and it's pressed
        className += " pressed"
      }
    } else if ( disabled
             && ( (side === "left" && player === 1)
               || (side === "right" & player === 2)
                )
             ) {
      className += " prompt"
    }

    return className
  }


  // console.log(disabled, gameState)

  let text

  if (side === "left") {
    if (vsAI && removed.length === removed.initial) {
      disabled = false
    }

    if (gameOver) {
      text = Theme.config.strings.playMate
      disabled = false

    } else {
      switch (player) {
        default: // AI or player2 is playing
          text = Theme.config.strings.player1
          disabled = true
        break
        case 1:
          text = disabled
               ? vsAI
                 ? Theme.config.strings.yourTurn // Your turn
                 : Theme.config.strings.player1
                   + Theme.config.strings.toPlay // Player 1 to play
               : Theme.config.strings.play       // Play
        break
      }
    }

  } else if (side === "right") {
    if (gameOver) {
      text = Theme.config.strings.playAI
      disabled = false

    } else if (vsAI) {
      disabled = true

      if (player) {
        if (hints && undo && winning) {
          text = Theme.config.strings.undo
          disabled = false
        } else {
          text = Theme.config.strings.ai
        }
      } else {
        text = Theme.config.strings.aiThinking
      }

    } else {
      switch (player) {
        case 1:
          text = Theme.config.strings.player2
          disabled = true
        break
        case 2:
          text = disabled
               ? Theme.config.strings.player2
                 + Theme.config.strings.toPlay // Player 2 to play
               : Theme.config.strings.play     // Play
        break
      }
    }
  }

  // When a button is active (pressed or rolled-off), button will
  // by truthy
  const className = getClassName()

  if (!unlocked) { disabled = true }

  return (
     <StyledButton
       disabled={disabled}
       onMouseDown={buttonDown}
       onTouchStart={buttonDown}
       className={className}
     >
       {text}
     </StyledButton>
  )
}


const Checkbox = ({ checked, onChange, disabled }) => {
  const className = "unselectable"
  // console.log("Checkbox", checked, onChange)

  return (
    <label
      htmlFor="showRules"
      className={className}
    >
      <HiddenCheckbox
        type="checkbox"
        id="showRules"
        onChange={onChange}
        checked={checked}
        disabled={disabled}
      />
      <StyledRulesButton
        checked={checked}
      >
        {Theme.config.strings.showRules}
      </StyledRulesButton>
    </label>
  )
}


/// MENU ///

const StyledControls = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  height: 100vh;
  z-index: 1;
  text-align: left;
`


const StyledSVG = styled.svg`
  position: fixed;
  display: ${props => props.visible ? "block" : "none"}
  width: 15vmin;
  height: 15vmin;
  fill: ${Theme.config.colors.textColor};
  opacity: ${props => (
    props.open ? 1 : (props.over ? 0.75 : 0.25)
  )}
  left: ${props => props.open ? "27vmin" : 0}
  transition: left .27s linear, opacity .15s;
  transition-property: left, opacity;
  transition-delay: ${props => props.open ? ".15s, 0s;" : "0s, .27s;"}
  ${props => props.disabled
           ? `pointer-events: none;cursor: default;`
           : `cursor: pointer;`
    }
`


const StyledMenu = styled.div`
  position: fixed;
  box-sizing: border-box;
  top: 0;
  left: ${props => props.open ? 0 : "-42vmin;"}
  ${props => props.open
          ? "box-shadow: 0 0 3vmin 0 rgba(0,0,0,0.75);"
          : ""
  }
  height: 100vh;
  width: 42vmin;
  padding: 2vmin;
  padding-top: 18vmin;
  background-color: ${colors.menu};

  transition: left .42s linear;
`


const StyledSubset = styled.div`
  margin: 2vmin 0 0 6vmin;
`


const StyledLabel = styled.label`
  display: block;
  margin-top: 4vmin;
  cursor: ${({ disabled }) => disabled ? "default" : "pointer"}
`


const Check = styled.svg`
  fill: none;
  stroke: ${Theme.config.colors.textColor}
  stroke-width: ${Theme.config.strings.buttonSize / 8 + "vmin"};
`


const StyledCheckbox = styled.div`
  display: inline-block;
  width: ${Theme.config.strings.buttonSize + "vmin"}
  height: ${Theme.config.strings.buttonSize + "vmin"}
  background: ${props => (
    props.checked ? colors.checked : colors.unchecked
  )}
  border-radius: 3px;
  transition: all 150ms;

  ${HiddenCheckbox}:focus + & {
    box-shadow: 0 0 0 3px ${colors.focus};
  }

  ${Check} {
    visibility: ${props => (props.checked ? 'visible' : 'hidden')}
  }
`


const StyledSpan = styled.span`
  font-size: ${Theme.config.strings.buttonSize + "vmin"};
  margin-left: 0.5em;
`


const ToggleButton = styled.button`
  background-color: transparent;
  background-image: url(${
    props => props.active
           ? props.on
           : props.off
  });
  border: 0.5vmin solid ${colors.shade};
  border-radius: 10vmin;
  width: 10vmin;
  height: 10vmin;
  margin: 0.75vmin;

  ${props => /*!props.disabled
             ?*/ !props.active
               ? `border-top-color: ${colors.tint};
                  border-left-color: ${colors.tint};`
               : `background-color: ${colors.darker};
                  border-color: ${colors.tint};
                  border-top-color: ${colors.shade};
                  border-left-color: ${colors.shade};`
              /*: `border-color: ${colors.basic};
                 opacity: 0.2;`*/
  }

  &:focus {
    outline: none;
  }
`


const Hintbox = ({ id, label, checked, onChange, disabled }) => {
  const className = "unselectable"
  // console.log("Hintbox", checked, onChange)

  return (
    <StyledLabel
      key={id}
      htmlFor={id}
      className={className}
      disabled={disabled}
    >
      <HiddenCheckbox
        type="checkbox"
        id={id}
        onChange={onChange}
        checked={checked}
        disabled={disabled}
      />
      <StyledCheckbox
        checked={checked}
      >
        <Check viewBox="0 0 24 24">
          <polyline points="20 4 9 17 4 12" />
        </Check>
      </StyledCheckbox>
      <StyledSpan>{label}</StyledSpan>
    </StyledLabel>
  )
}


const Restart = ({ children, onClick, disabled }) => {
  // console.log("children:", children, "onClick:", onClick, "disabled:", disabled )
  return (
  <StyledButton
    disabled={disabled}
    onClick={onClick}
    style={{
      width: "38vmin"
    }}
  >
    {children}
  </StyledButton>
)}


const ButtonBlock = ({ callback, buttonStates }) => {
  // console.log("ButtonBlock", "callback:", callback, "buttonStates:", buttonStates)
  return (
    <div
      id="block"
      style={{
        position: "absolute"
      , bottom: 0
      , left: 0
      , display: "flex"
      , justifyContent: "space-between"
      , width: "100%"
      }}
    >
      <Credits
        visible={buttonStates.credits}
      />
      <ToggleButton
        active={buttonStates.credits}
        on={Theme.config.menu.credits}
        off={Theme.config.menu.credits}
        onClick={() => callback("credits")}
        style={{zIndex: 3}}
      />
      <div>
        <ToggleButton
          active={buttonStates.sfx}
          on={Theme.config.menu.sfx}
          off={Theme.config.menu.nosfx}
          onClick={() => callback("sfx")}
        />
        <ToggleButton
          active={buttonStates.music}
          on={Theme.config.menu.music}
          off={Theme.config.menu.nomusic}
          // disabled={!buttonStates.sfx}
          onClick={() => callback("music")}
        />
      </div>
    </div>
  )
}


const Items = ({ onChange, menuOpen, menuState, pane  }) => {
  const menu = Theme.config.menu
  const { restart, allowHints } = menu
  const { callback, checkList, gameState } = menuState
  const { credits, music, sfx, gameOver } = gameState

  const menuItems = (function menuItems() {

  // console.log("menuItems gameState", gameState)

    if (!allowHints) {
      return []
    }

    return ["undo", "steps", "tips", "groups"]
    .filter( hint => {
      const allow = "allow"
                  + hint[0].toUpperCase()
                  + hint.substring(1)

      // console.log("filter", allow, menu[allow])

      if (menu[allow]) {
        return true
      }
    }).map( hint => (
      <Hintbox
        key={hint}
        id={hint}
        label={menu[hint]}
        checked={checkList[hint]}
        onChange={(event) => onChange(event, hint)}
        disabled={!checkList.hints}
      />
    ))
  })()

  // console.log(menu)

  const hints = (menuItems) => (
    <StyledMenu
     id="Items"
     ref={pane}
     open={menuOpen}
    >
      <Restart
        disabled={gameOver}
        onClick={() => onChange("restart")}
      >
        {restart}
      </Restart>
      <Hintbox
        key="hints"
        id="hints"
        label={menu.hints}
        checked={checkList.hints}
        onChange={(event) => onChange(event, "hints")}
      />
      <StyledSubset>
        {menuItems}
      </StyledSubset>
      <ButtonBlock
        callback={callback}
        buttonStates={{ credits, music, sfx }}
      />
    </StyledMenu>
  )

  return hints(menuItems)
}


/// ANTS ///

const Ants = ({ rect }) => {

  if (!rect) {
    return ""
  }

  const StyledRect = styled.rect`
  @keyframes ants {
    from { stroke-dashoffset: 0; }
    to { stroke-dashoffset: ${ants.length * 2}; }
  }

  @keyframes tsan {
    from { stroke-dashoffset: ${-ants.length}; }
    to { stroke-dashoffset: ${ants.length}; }
  }
  `
  const antsAnimation = {
    animation: `ants ${ants.time}s linear infinite`
  }

  const svg = (
    <svg
      id="Ants"
      width="100vw"
      height="100vh"
      xmlns="http://www.w3.org/2000/svg"
      xmlnsXlink="http://www.w3.org/1999/xlink"
      style={{
        position: "fixed"
      , top: 0
      , left: 0
      , pointerEvents: "none"
      }}
    >
      <StyledRect
        x={rect.x}
        y={rect.y}
        rx={ants.radius}
        width={rect.width}
        height={rect.height}
        stroke={ants.dark}
        strokeWidth={ants.width}
        strokeLinecap="round"
        strokeOpacity="0.75"
        strokeDasharray={ants.dashArray}
        style={antsAnimation}
        fill={ants.dark}
        fillOpacity={ants.opacity}
      />
      <StyledRect
        x={rect.x}
        y={rect.y}
        rx={ants.radius}
        width={rect.width}
        height={rect.height}
        stroke={ants.light}
        strokeWidth={ants.width}
        strokeOpacity="0.75"
        strokeLinecap="round"
        strokeDasharray={ants.dashArray}
        style={{ animation: `tsan ${ants.time}s linear infinite` }}
        fill="none"
      />
    </svg>
  )

  return svg
}



/// CREDITS

const StyledCredits = styled.div`
  display: ${props => props.visible
                    ? "block"
                    : "none"
             }
  position: fixed;
  top: 0;
  left: 0;
  height: 100vh;
  width: 100vw;
  background-color: ${colors.winner};
  text-align: center;
  overflow-y: auto

  & ul {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  & h1 {
    font-size: ${Theme.config.credits.h1Size}vmin;
    margin: 1em 0 0;
  }

  & h2 {
    font-size: ${Theme.config.credits.h2Size}vmin;
    margin: 1.5em 0 0;
  }

  & p {
    font-size: ${Theme.config.credits.pSize}vmin;
    margin: 0.25em;
  }

  & a {
    color: ${colors.text}
  }
`

const Credits = ({ visible }) => {
  const credits = Theme.config.credits

  const items = credits.credit.map((data, index) => (
    <li key={index}>
      <h2><a target="credits" href={data.url}>{data.name}</a></h2>
      <p>{Theme.config.credits.by} {data.author}</p>
      <p><a target="credits" href={data.licenseURL}>{data.license}</a></p>
    </li>
    )
  )

  return (
    <StyledCredits
      visible={visible}
    >
      <h1>{Theme.config.credits.credits}</h1>
      <ul>
        {items}
      </ul>
    </StyledCredits>
  )
}



/// CLASSES ///

/**
 * this.props will be:
 * { id: "board"
 * , action: pointer to GamePage.startDrag()
 * , rows: []
 * }
 *
 * @class      Board (name)
 */
class Board extends React.Component {
  _getRowsToRender() {
    const {
      removed
    , selected
    , activeIds
    , dragIds
    , gameOver
    } = this.props.gameState

    // console.log("Board._getRowsToRender: props.activeIds", this.props.activeIds)

    const rows = this.props.rows.map((row, rowIndex) => {
      const gaps = row.reduce((gaps, cell) => (
        gaps + !(removed.indexOf(cell.name) < 0)
      ), 0)
      // console.log("row:", row, "gaps:", gaps)

      const cells = row.map((cell, cellIndex) => {
        // { "name": "cell_N"
        // , "theme": {
        //     "rotation": `transform: rotate(DEGREEdeg);
        //                  filter: drop-shadow(X Y Z COLOR);`
        //   , "padding": "TOPvmin RIGHTvmin LEFTvmin BOTTOMvmin"
        //   , "spacing": "TOPvmin RIGHTvmin LEFTvmin BOTTOMvmin"
        //   , "equal":   "TOPvmin RIGHTvmin LEFTvmin BOTTOMvmin"
        //   }
        // , "image": <URL>
        // }
        //
        // console.log(this.props)
        const id        = cell.name
        const className = selected.indexOf(id) < 0
                        ? ""
                        : "selected"
        const active    = !gameOver
                       && !activeIds.length
                       || !(activeIds.indexOf(id) < 0)
        const cursor    = active
                        ? "pointer"
                        : "not-allowed"

        // console.log("active:", active, "id:", id, "gameOver:", gameOver, "activeIds:", activeIds)

        const image = (removed.indexOf(id) < 0)
                    ? (<StyledImage
                        theme={cell.theme} // rotation & drop-shadow filter
                        src={cell.image}
                        cursor={cursor}
                        gameOver={this.props.gameOver}
                      />)
                    : ""

        // console.log("groups:", this.props.gameState.groups)

        return (
          <StyledShrinkWrap
            key={id}
            theme={cell.theme} // uses padding
            groups={this.props.gameState.groups
                 && this.props.gameState.hints
                 && this.props.gameState.vsAI}
            gaps={gaps}
          >
            <StyledFrame
              className={className}
              id={id}
              data-title={cell.title}
            >
              {image}
            </StyledFrame>
          </StyledShrinkWrap>
        )
      }) // End of row.map()

      return (
        <StyledRow
          key={rowIndex}
          id={"row-" + rowIndex}
        >
          {cells}
        </StyledRow>
      )
    })

    return rows
  }


  render() {
    const rows = this._getRowsToRender()
    // console.log("Board", this.props.gameState)

    return (
      <StyledBoard
        id="Board"
        onMouseDown={this.props.action}
        onTouchStart={this.props.action}
      >
        {rows}
      </StyledBoard>
    )
  }
}


class Menu extends React.Component {
  constructor (props) {
    // console.log("Menu props", props)
    super(props)

    // Create a ref so that we can detect a mousedown outside the
    // ref in closeMenu
    this.pane = React.createRef()

    this.callback = props.callback
    this.onChange = this.onChange.bind(this)
    this.openMenu = this.openMenu.bind(this)
    this.closeMenu  = this.closeMenu.bind(this)
    this.state = { menuOpen: false } // true } //
  }


  openMenu(event) {
    const canOpen = this.props.gameState.unlocked // belt and braces
                 && !this.state.menuOpen
                 && !this.ignoreOpen
    if (canOpen) {
      this.setState({ menuOpen: true })

      const listener = this.closeMenu
      document.body.addEventListener("touchstart", listener, true)
      document.body.addEventListener("mousedown", listener, true)
    }
  }


  closeMenu(event) {
    // Check if the click was inside the slide-out menu. If not,
    // close the menu

    if (event.type === "touchstart") {
      // Prevent the mouseup from firing right behind
      this.timeout = setTimeout(() => this.timeout = 0, 300)
    } else if (this.timeout) {
      return
    }

    const pane = this.pane.current
    if (pane&& !pane.contains(event.target)) {
      this.setState({ menuOpen: false })

      // Prevent
      this.ignoreOpen = true
      setTimeout(() => this.ignoreOpen = false, 100)

      const listener = this.closeMenu
      document.body.removeEventListener("touchstart", listener, true)
      document.body.removeEventListener("mousedown", listener, true)
    }
  }


  onChange(event, hint) {
    // console.log(event.target, hint)
    if (event === "restart") {
      this.setState({ menuOpen: false })
      return this.callback("restart")
    }

    // Toggle hint
    const checkList = this.props.checkList
    const state = checkList[hint] = !checkList[hint]
    const action = {}
    action[hint] = state

    this.setState({ checkList })

    this.callback(action) // { <hint>: <boolean> }
  }


  render() {
    // console.log("Menu prop:", this.props)

    return (
      <StyledControls
        id="Controls"
      >
        <Items
          pane={this.pane}
          onChange={this.onChange}
          menuOpen={this.state.menuOpen}
          menuState={this.props}
        />
        <StyledSVG
          id="openMenu"
          viewBox="0 0 100 100"
          preserveAspectRatio="xMidYMid meet"
          open={this.state.menuOpen}
          onClick={this.openMenu}
          disabled={!this.props.gameState.unlocked}
          visible={!this.props.gameState.credits}
        >
          <g className="menu">
            <path d="
              M5,20
              L5,80
              H95
              L95,20
              z" opacity="0" />
            <path d="
              M15,10
              H85
              a 10 10 180 0 1 0 20
              H15
              a 10 10 180 0 1 0 -20
              z" />
            <path d="
              M15,40
              H85
              a 10 10 180 0 1 0 20
              H15
              a 10 10 180 0 1 0 -20
              z" />
            <path d="
              M15,70
              H85
              a 10 10 180 0 1 0 20
              H15
              a 10 10 180 0 1 0 -20
              z" />
          </g>
        </StyledSVG>
      </StyledControls>
    )
  }

  // Restart ↻
  // Undo    ⎌ ⭯
  // Steps
  // Tips   ⭗ 🞊
  // Groups
}


class Storage {
  constructor() {
    const menu = Theme.config.menu
    const defaults = {
      hints: {
        hints: menu.hintsByDefault
      , undo: menu.undoByDefault
      , tips: menu.tipsByDefault
      , steps: menu.stepsByDefault
      , groups: menu.groupsByDefault
      }
    , level: -1
    , music: true
    , sfx: true
    }
    // console.log("default storage", defaults)

    try {
      this.storageName = window.localStorage ? "Nim" : false
      let storage = localStorage.getItem(this.storageName)
      if  (!storage) {throw new Error("Storage is empty")}
      this.storage = JSON.parse(storage)
    } catch(error) {
      this.storage = defaults
    }

    // console.log("actual storage", this.storage)
  }


  get(key) {
    return this.storage[key]
  }


  setHints(map) {
    this.storage.hints = {...this.storage.hints, ...map}
    this._save()
  }


  setLevel(level) {
    this.storage.level = level
    this._save()
  }


  setAudio(type, state) {
    this.storage[type] = state
    this._save()
  }


  _save() {
    if (this.storageName) {
      const storageString = JSON.stringify(this.storage)
      localStorage.setItem(this.storageName, storageString)
    }
  }
}


class SetUp {
  constructor(storage, levels) {
    this.storage = storage
    this.levels = levels
    this.level = storage.get("level")
    this.maxLevel = this.levels.length - 1
  }


  get({ vsAI, hints, steps, assets, fail, level, groups }) {
    this.assets = assets // \\
    this.groups = groups // // used in _getRemoved

    if (this.level < 0) {
      // Play the full game the first time, even if steps is true
      if (vsAI) {
        this.level = 0
      }
      
      level = this.maxLevel
      fail = 0
    }

    if (!vsAI || !hints || !steps ) {
      // Use combination with all items in place
      level = this.maxLevel
    } else if (isNaN(level)) {
      level = this.level
    }

    this._adjustLevel(fail, steps)

    let removed
      , gameState

    if (level === this.maxLevel) {
      removed = []
      gameState = {
        objectsInRows:   [1, 3, 5, 7]
      , rowsWithObjects: [0, 1, 2, 3]
      }
    } else {
      ({ removed, gameState } = this._getSetup(level))
    }

    removed.initial = removed.length

    const restore = {
      removed
    , assets
    , gameState
    }

    const state = {
      gameOver:  false
    , showRules: false
    , fail:      false
    , waitForAI: false
    , vsAI
    , level
    , removed
    , player:    1
    , activeRow: -1
    , activeIds: []
    , selected:  []
    , winner:    ""
    }

    return { state, restore }
  }


  setLevel(level) {
    if (isNaN(level)) {
      return false
    }

    this.level = Math.max(0, Math.min(level, this.maxLevel))
    return this.level
  }


  getLevel(level) {
    if (isNaN(level)) {
      level = this.level
    } else {
      level = Math.max(0, Math.min(level, this.maxLevel))
    }

    return this.levels[level].toString()
  }


  _adjustLevel(fail, steps, level) {
    if (!steps || fail === 0) {
      return
    } if (!fail) {
      this.level = Math.min(this.level + 1, this.maxLevel)
      this.storage.setLevel(this.level)
      return
    }

    // Move the failed level back a few places... unless we're already
    // at maxLevel
    const combination = this.levels.splice(this.level, 1)[0]
    const range  = Math.ceil(
                     Math.min(this.maxLevel - this.level, 16) / 2
                   ) // between 0 and 8
    const random = Math.ceil(Math.random() * range) // 0 - 8
                 + range                            // 0 - 8
                 + this.level
    this.levels.splice(random, 0, combination)
  }


  _getSetup(level) {
    const objectsInRows = this._getPlaces(level)
    const rowsWithObjects = objectsInRows.map((rowCount, index) => (
      rowCount ? index : false
    )).filter( index => index !== false )

    const removed = this._getRemoved(objectsInRows)

    return {
      removed
    , gameState: {
        objectsInRows
      , rowsWithObjects
      }
    }
  }


  _getPlaces(level) {
    const combination = [...this.levels[level]]
    const places = [0, 0, 0, 0]
    const spaces = [1,3,5,7]
    let rowCount

    while (rowCount = combination.pop()) {
      const index = this._getRowIndex(rowCount, spaces)
      places[index] = rowCount
      spaces[index] = 0
    }

    return places
  }


  _getRowIndex(rowCount, spaces) {
    const available = spaces.map(
      (spaceCount, index) => (rowCount > spaceCount) ? false : index
    ).filter(
      index => index !== false
    )

    const random = Math.floor(Math.random() * available.length)
    return available[random]
  }


  _getRemoved(objectsInRows) {
    const removed = []
    const rowArray = this.assets.map( rowData => (
      rowData.map( cell => cell.name )
    ))

    // console.log(rowLUT)
    rowArray.forEach((rowData, index) => {
      const cells     = rowArray[index]
      let cellCount   = rowData.length
      const itemCount = objectsInRows[index]
      let excess      = cellCount - itemCount

      if (excess) {
        if (this.groups) {
          const binary    = {1: 1, 3: 7, 5: 31, 7: 127}[cellCount]
          let adjustData = adjusts[binary]
          adjustData = adjustData[adjustData.length - 1]
          adjustData = adjustData[excess] || binary

          while (adjustData) {
            cellCount -= 1

            if (adjustData % 2) {
              removed.push(cells[cellCount])
            }

            adjustData = adjustData >>> 1
          }

        } else {
          // Remove random items
          while (excess--) {
            const random = Math.floor(Math.random() * cells.length)
            removed.push(cells.splice(random, 1)[0])
          }
        }
      }
    })

    return removed
  }
}


class NoAnimation {
  // Does nothing when instantiated 
}


class Game extends React.Component {
  constructor() {
    super()

    window.jazyx = { game: this }

    // The preloader will do its best to load all the assets in a
    // given number of milliseconds and then will start the game 
    // without the missing assets. The list of missing assets will be
    // logged in the console.
    preload(2000).then( result => result )
                 .catch( error => error )
                 .then( result => this._unlockGame(result))
    
    this.storage = new Storage()

    this.aiPlay          = this.aiPlay.bind(this)
    this.setLevel        = this.setLevel.bind(this)
    this.startDrag       = this.startDrag.bind(this)
    this.buttonDown      = this.buttonDown.bind(this)
    this.toggleRules     = this.toggleRules.bind(this)
    this.menuCallback    = this.menuCallback.bind(this)
    this.killContextMenu = this.killContextMenu.bind(this)

    this.strings         = Theme.config.strings
    this.stringLUT       = this._getStringLUT(this.strings)

    // By default, provide no tips and no text animation...
    this.TextAnimator = NoAnimation // by default
    this.showTips = function () {}
    // ... but apply specific methods and classes if available
    switch (Theme.config.menu.tipType) {
      case "name":
        this.showTips = name ? name : this.showTips  
      break
      case "flip":
        this.showTips = flip ? flip : this.showTips  
      break
      case "zalgo":
        this.showTips = zalgo ? zalgo : this.showTips
        this.TextAnimator = Zalgo ? Zalgo : this.TextAnimator
      break
    }

    this.state = {
      gameOver:    true
    , selected:    [] // \
    , removed:     [] //  will contain StyledFrame ids
    , activeIds:   [] // /
    , showRules:   true
    , music:   this.storage.get("music")
    , sfx: this.storage.get("sfx")
    , ... this.storage.get("hints")

    // , winner:      true // HACK to show rules on startup

    // , activeRow: -1
    // , selected:  []
    // , vsAI:      false
    // , player:    0
    // , winner:    ""
    // , button:    { side <"left"|"right">, down: <boolean> }
    }

    // this.rowMap // { <img id>: <integer row number, ... }
    // this.ai

    // this.assets = [[{
    //   "name":"cellN",
    //   "theme": {
    //       'rotation": 'transform: rotate(ANGLEdeg);
    //        filter:    drop-shadow(Xvmin Yvmin 0.2vmin COLOR);`
    //     , "padding":  "TOPvmin RIGHTvmin LEFTvmin BOTTOMvmin"
    //     , "spacing":  "TOPvmin RIGHTvmin LEFTvmin BOTTOMvmin"
    //     }
    //   , "image": <url>
    //   }]
    // , [ <object>, ...]
    // , ... more rows
    // ]

    // this.selected = [ array of ids already selected on startDrag]
    // this.tracker = tracks changes in this.selected   

    this._prepareMusic()
    this.pool = new Pool()
    this.setUp = new SetUp(this.storage, levels) // from const
    this.setUpPieces()
  }


  componentDidMount() {
    this.killContextMenu() // COMMENT OUT for debugging
  }


  setUpPieces() {
    if (this.state.unlocked && !this.state.winner) {
      // Setup was already called from constructor.
      return
    }

    this.background = this._getBackgroundImage()
    this.resources = {
      title:  []
    , image:  []
    , select: []
    , reject: []
    }
    this.assets = this._getAssetsByRow(Theme.config.random)

    // const images = [].slice
    //                  .call(document.querySelectorAll("img.removed"))
    // images.forEach( image => {
    //   image.classList.remove("removed")
    // })
    this.pool.fillWith(this.assets)
  }


  /**
   * buttonDown is called by a mousedown or touchstart on either the
   * left (Play a Friend | Player 1) or the right button (Play the AI
   * | Undo)
   *
   * This method tracks the movement of the mouse or touch until
   * mouseup or touchend somewhere on the screen, showing the state
   * of the button (down | not pressed) as appropriate, and triggering
   * the expected action only if the cursor|touch is over the button
   * at the end of the gesture.
   *
   * ISSUE: on Android if you the page is scrolled up to hide the
   * address bar, and you click on the button and drag up and then
   * down again, the page will scroll down and the button position
   * will readjust. However, the system will not know that the button
   * has moved and so the button may not trigger, or may trigger
   * unexpectedly.
   *
   * @param    {string}  side    "left" | "right"
   * @param    {<type>}  event   The event
   */
  buttonDown(side, event) {
    // console.log("buttonDown")

    event.preventDefault()
    event.stopPropagation()
    if (event.type === "touchstart") {
        this.timeout = setTimeout(() => { this.timeout = 0 }, 300)

    } else if (this.timeout) {
      return
    }

    const target = event.target
    let lastTouch

    const getElementUnderTouch = (event) => {
      const t = event.targetTouches[0]
      lastTouch = { targetTouches: [
        { clientX: t.clientX, clientY: t.clientY }
      ]}
      return document.elementFromPoint(t.clientX, t.clientY)
    }

    const toggleButtonState = (event) => {
      let type = event.type
      const button = this.state.button

      if (event.type === "touchmove") {
        const element = getElementUnderTouch(event)

        if (element === target) {
          if (button.down) {
            return
          } else {
            type = "mouseenter"
          }
        } else if (button.down) {
          type = "mouseleave"
        } else {
          return
        }
      }

      button.down = (type === "mouseenter")

      this.setState({ button })
    }

    const buttonUp = (event) => {
      if (event.type === "touchend") {
        event = { target: getElementUnderTouch(lastTouch) }
      }

      if (event.target === target) {
        const action = this.stringLUT[event.target.innerText]

        if (this[action]) {
          this[action]()
        }
      }

      // Cancel any further button action ... until the next click
      document.body.onmouseup
        = document.body.ontouchend
        = target.onmouseenter
        = target.onmouseleave
        = target.ontouchmove
        = null
      this.setState({ button: null })
    }

    if (event.type === "touchstart") {
      getElementUnderTouch(event)
    }
    this.setState({ button: { down: true, side }})

    document.body.onmouseup
      = document.body.ontouchend
      = buttonUp
    target.onmouseleave
      = target.onmouseenter
      = target.ontouchmove
      = toggleButtonState
  }


  toggleRules(event) {
    this.setState({ showRules: event.target.checked })
  }


  // TAKING A TURN

  playAI() {
    this.ai = new AI(this.aiPlay)
    this._startNewGame(true)

    const noHints = !this.state.hints
                 || !( this.state.undo
                    || this.state.steps
                    || this.state.tips
                    || this.state.groups
                     )
    this.setState({ noHints })
  }


  playMate() {
    this._startNewGame(false)
  }


  /**
   * Simulates a move made by the AI
   *
   * @param  {object} move  { row:   <integer row to take items from>
   *                        , count: <integer number of items to take>
   *                        }
   */
  aiPlay({ move, prediction }) {
    let { row, count, winning } = move
    this.setState({ winning })
    let { min, max } = { min: 400, max: 500 }
    let id

    this.showTips([])

    const lost = !winning && !prediction
    // console.log("AI played row", row, "count:", count, "winning:", winning)

    const getRandomDelay = (pause=0) => {
      if (lost) {
        return min
      }

      const random = Math.floor(Math.random() * (max - min)) + min
      max = random
      return random + pause
    }

    const getPromise = (id) => {
      return new Promise((resolve, reject) => {
        const delay = getRandomDelay()
        setTimeout(() => {
          this._playSFX({ plus: [id], minus: [] }, true)
          const selected = (this.state.selected).concat(id)
          this.setState({ selected })
          // console.log("Resolving " + id + " after " + delay + "ms")
          resolve(id)
        }, delay)
      })
    }

    const pressAIButton = () => {
      // Show AI Play button down...
      const button = { side: "right", down: true }
      this.setState({ button })

      // ... then "release" it shortly after
      setTimeout(applyAIMove, getRandomDelay(500))
    }

    const applyAIMove = () => {
      if (!winning) {
        this._setRestorePoint()
        // console.log("Restore to", this.restore)
      }

      this.setState({ button: null })
      this.showTips([])
      this._showPrediction(prediction)
          .then(
            () => this.play(1)
          )
    }

    // console.log("aiPlay row:", row, "count:", count)

    row = this._getMarkedItems(row, count)
    if (row.length !== count) {
      throw new Error()
    }

    // console.log("row", row)
    const sequence = row.reduce((sequence, id) => {
      return sequence.then(() => {
        return getPromise(id)
      })
    }, Promise.resolve())

    sequence.then(() => pressAIButton())
  }


  _getMarkedItems(row, count) {
    let items = []

    const getGroupedCells = () => {  
      const ids = this._getActiveIds(this.assets[row])
      let index = ids.length - 1
      let binary = this._getBinary(ids)
      let data = adjusts[binary]
      if (Array.isArray(data)) {
        data = data[data.length - 1]
      }

      binary = (data && data[count]) || binary

      while (binary) {
        if (binary % 2) {
          items.push(ids[index])
        }

        binary = binary >>> 1
        index -= 1
      }
    }

    const getConsecutiveBlock = () => {
      // Get an array of the remaining item ids in the chosen row
      const { removed } = this.state

      items = this.assets[row].filter( cell => (
        removed.indexOf(cell.name) < 0
      )).map( cell => cell.name )

      const index = Math.floor(Math.random() * (items.length - count))
      items = items.slice(index, index + count)
    }


    if (this.state.groups && this.state.hints) {
      getGroupedCells()

    } else {
      getConsecutiveBlock()
    }

    if (count > 1 && Math.floor(Math.random() * 2)) {
      items = items.reverse()
    }

    return items
  }


  _showPrediction(prediction) {
    if (!prediction || !this.state.tips || !this.state.hints) {
      return Promise.resolve()
    }

    // console.log(prediction)

    let { row, count } = prediction
    row = this._getMarkedItems(row, count) // array of ids
    row = "#" + row.join(", #")            // selector string
    row = [].slice.call(document.querySelectorAll(row)) // elements
    // ["cell-N", ...]

    this.showTips(row)

    return Promise.resolve()
  }


  play(player) {
    const checkForGameOver = (removed) => {
      if (removed.length === 16) {
        const player = this.state.player
        let winner

        if (player) {
          if (this.state.vsAI) {
            winner = ["AI-wins"]
            this.setState({ fail: true })

          } else {
            winner = ["player"+(3 - player), "wins"]
          }
        } else if (this.state.noHints) {
          winner = ["ace"]

        } else if (this.state.level === levels.length - 1){
          winner = ["you-top"]

        } else {
          winner = ["you-win"]
        }

        winner = winner.map( key => (
          this.strings[key]
        )).join("")
        this.setState({ winner })

        return true
      }

      return false
    }

    let { activeRow: row, selected } = this.state

    selected = selected.filter(id => id) // remove 0
    const pass = !selected.length // silence click on play if pass
    const removed = this.state.removed.concat(selected)
    const gameOver = checkForGameOver(removed)
    player = player || (this.state.vsAI
                 ? 0
                 : 3 - this.state.player // 1->2; 2->1
                 )

    this.setState({
      selected:  []
    , removed
    , activeRow: -1
    , activeIds: []
    , player
    , waitForAI: !player
    , gameOver
    , showRules: false
    })

    // console.log("play waitForAI:", !player)

    if (!gameOver && !player) {
      this._showGroups(row).then(() =>
        this.ai.reactToPlayerMove({ row, count: selected.length })
      )
    }

    this._playSound(gameOver, player, pass)
  }


  _showGroups(row) {
    const promise = Promise.resolve()

    if (!this.state.hints || !this.state.groups || row < 0) {
      return promise
    }

    const assets = this.assets[row]
    const ids = this._getActiveIds(assets)
    const binary = this._getBinary(ids)
    const groupData = adjusts[binary]

    if (!Array.isArray(groupData) || isNaN(groupData[0])) {
      // Items are already arranged in groups
      return promise
    }

    // If we get here, there are items to move

    const length = assets.length
    let promiseData = []
    let [ shifts, result ] = groupData  
    // Shifts will be a number of the format st[st]+
    // where the digits s = source and t = target location
    let source
      , sourceId
      , target
      , targetId
      , data

    while (shifts) {
      source = length - (shifts % 10)
      shifts = Math.floor(shifts / 10)
      target = length - (shifts % 10)
      shifts = Math.floor(shifts / 10)
      data   = this._getPromiseData(source, target, assets)
      promiseData.push(data)
    }

    promiseData = promiseData.map( data => this._groupPromise(data) )

    return Promise.all(promiseData)
  }


  _getPromiseData(source, target, assets) {
    const sourceId = assets[source].name
    const targetId = assets[target].name

    const element =  document.getElementById(sourceId)
    const left = element.getBoundingClientRect().left
               - document.getElementById(targetId)
                          .getBoundingClientRect().left

    return { source, target, element, left, assets }  
  }


  _groupPromise({ source, target, element, left, assets }) {
    return new Promise((resolve, reject) => {
      const completeMove = event => {
        element.removeEventListener("transitionend", completeMove)
        element.classList.remove("group")
        element.style.removeProperty("left")
        resolve()
      }  
        
      // Swap visible with removed item...
      [ assets[source], assets[target]]
        = [assets[target], assets[source]]
      // ... and apply the left adjust so swapped item won't move
      element.style.left = left + "px"

      // Then apply a class that cancels the left adjust and
      // includes a transition duration...
      setTimeout(() => {
        element.classList.add("group")
      }, 0)

      // ... and prepare to remove both left and cancel-left-class
      // when the transition ends
      element.addEventListener("transitionend", completeMove)
    })
  }


  _getBinary(ids) {
    return ids.reduce((binary, cellName) => {
      return binary * 2 + (cellName ? 1 : 0)
    }, 0)
  }  


  _getActiveIds(assets) {
    return assets.map( asset => (
      this.state.removed.indexOf(asset.name) < 0
      ? asset.name
      : 0
    ))
  }


  _setRestorePoint() {
    const removed = this.state.removed.concat(this.state.selected)
    const objectsInRows = this.assets.map( row => (
      row.filter( cell => removed.indexOf(cell.name) < 0 )
         .reduce( counter => counter + 1, 0 )
    ))
    const assets = JSON.parse(JSON.stringify(this.assets))
    // console.log("objectsInRows:", objectsInRows)
    const rowsWithObjects = objectsInRows.map((count, index) => (
      count ? index : -1
    )).filter( index => !(index < 0))

    // console.log("rowsWithObjects:", rowsWithObjects)

    this.restore = {
      removed
    , assets
    , gameState: {
        objectsInRows
      , rowsWithObjects
      }
    }
  }


  // <<<PRELOADING 

  _unlockGame(result) {
    result = result.filter( item => !!item )
    if (result.length) {
      console.log("Missing assets:" + JSON.stringify(result))
    }
    this.setState({ unlocked: true })
  }


  // <<< SELECTING ITEMS 

  startDrag(event) {
    // console.log("startDrag waitForAI:", this.state.waitForAI)
    if (this.state.waitForAI) {
      // console.log("action denied")
      return
    }

    event.preventDefault()
    event.stopPropagation()
    if (event.type === "touchstart") {
        this.timeout = setTimeout(() => { this.timeout = 0 }, 300)

    } else if (this.timeout) {
      return
    }

    if (this.state.gameOver) {
      return
    }

    const target = event.target
    if (target.tagName !== "IMG") {
      return
    }

    const id = target.parentNode.id
    if (!(this.state.removed.indexOf(id) < 0)) {
      console.log("Removed image clicked?!", id)
      return
    }

    const rowNumber = this.rowMap[id]
    const activeRow = this.state.activeRow

    if (activeRow < 0) {
      // This is necessarily a selection (not a deselection), because
      // nothing is selected in any row
      this.setState({ activeRow: rowNumber })
      // console.log("activeRow", rowNumber)

    } else if (activeRow !== rowNumber) {
      // Can't select objects in two different rows
      return
    }

    this.tracker = getDifferences()
    this._showSelection(event, rowNumber, id)
  }


  _showSelection(event, rowNumber, id) {
    this.selected = [...this.state.selected]
    const isSelect = this.selected.indexOf(id) < 0
    const rowDetails = this._getRowDetails(rowNumber, isSelect)
    // { activeIds, dragIds [, outlineRects, unionRect] }
    //
    // outlineRects and unionRect will be missing if dragIds only has
    // one entry, meaning that there is no point in using drag to
    // extend the selection.
    // console.log(rowDetails)

    // Ensure that all the items in the clicked row will show the
    // pointer cursor, and that all others will show not-allowed
    const { activeIds, dragIds } = rowDetails
    const allowDrag = !!rowDetails.outlineRects
                   && ( isSelect
                        ? Theme.config.select.enableSelect
                        : Theme.config.select.enableDeselect
                      )
    // console.log("_showSelection activeIds:", activeIds)
    this.setState({ dragIds })

    // Change the selection state of the image that was pressed
    // (this may reset activeIds to [], if the clicked item was the
    // only item selected in this row)...
    this._previewSelection(isSelect, [ id ], activeIds, rowNumber)

    // ... and then deal with extending or annulling the change
    if (allowDrag) {
      this._prepareToExtendSelection(event, isSelect, id, rowDetails)
    } else {
      this._checkForRetraction(event, isSelect, id, activeIds)
    }
  }


  _getRowDetails(rowNumber, isSelect) {
    const rowDetails = {}
    const { selected, removed } = this.state

    // Get an array of ids...
    // * in row rowNumber...
    // * that are not marked as removed
    const activeIds
      = rowDetails.activeIds
      = Object.keys(this.rowMap)
              .filter( id => this.rowMap[id] === rowNumber
                          && removed.indexOf(id) < 0
                     )

    // Filter for only those which can be selected by a drag action
    const dragIds = rowDetails.dragIds = activeIds.filter(
      id => (selected.indexOf(id) < 0) === isSelect
    )

    if (dragIds.length === 1) {
      // The item that the player clicked is the only one in this row
      // in the current state, so there is no reason to calculate
      // data for a marching ants selection rect.

    } else {
      // Make a string list of ids of the elements that can be
      // selected, ...
      const selector = "#" + dragIds.join(", #")

      const elements = [].slice
                         .call(document.querySelectorAll(selector))

      // ... find the rect of each corresponding element, ...
      const outlineRects = rowDetails.outlineRects = elements.map(
        element => element.getBoundingClientRect()
      )
      // ... and the rect that finds them all and in the darkness binds
      // them
      rowDetails.unionRect = union(outlineRects)
    }

    return rowDetails
  }


  _prepareToExtendSelection(event, isSelect, id, rowDetails) {
    // By default, React provides a single-use event, so we need to
    // tell React not to recycle it, so we can continue to use it.
    event.persist()

    // Get ready to drag-select others in the same line
    detectMovement(event, 10) // promise
    .then(
      (drag) => this._showMarchingAnts(event, isSelect, rowDetails)
    , (drop) => this._previewSelection(isSelect, [ id ], rowDetails.activeIds)
    ).catch(
      (error) => console.log("Marching Ants promise", error)
    )
  }


  _checkForRetraction(event, isSelect, id, activeIds) {
    let within = true

    const drag = (event) => {
      const { x, y } = getPageXY(event)
      const elements = document.elementsFromPoint(x, y)

      // The click was on the image; the id that we are tracking
      // is on the (square) div that contains the image
      if (elements[1] && elements[1].id === id) {
        if (!within) {
          this._previewSelection(isSelect, [ id ], activeIds)
          within = true
        }

      } else if (within) {
        this._previewSelection(isSelect, [], activeIds)
        within = false
      }
    }

    const drop = (event) => {
      this._updateSelection()
      setTrackedEvents(cancel)
    }

    const cancel = setTrackedEvents({ event, drag, drop })
  }


  _showMarchingAnts(event, isSelect, rowDetails) {
    // This method is called only once per drag action, so we can
    // store the start loc here.
    const activeIds = rowDetails.activeIds
    const { x: startX, y: startY } = getPageXY(event)

    // Find which items intersect with the dragged ants rect, and
    // what their individual rects are
    const getSelectionMap = (antRect) => (
      rowDetails.outlineRects.reduce((map, rect, index) => {
        if (intersect(rect, antRect)) {
          map.ids.push(rowDetails.dragIds[index])
          map.rects.push(rect)
        }
        return map
      }, { ids: [], rects: [] })
    )

    const drag = (event) => {
      let { x, y } = getPageXY(event)

      // Check if the mouse is currently inside the largest marching
      // ant rect, before we modify x and y:
      const within = pointWithin(x, y, rowDetails.unionRect)

      const right  = Math.max(startX, x)
      x            = Math.min(startX, x)
      const width  = right - x
      const bottom = Math.max(startY, y)
      y            = Math.min(startY, y)
      const height = bottom - y

      let antRect  = { x, y, right, bottom, width, height }
      const map    = getSelectionMap(antRect)

      const revert = (!within && map.ids.length < 2 )

      // console.log("isConfirmedSelect:", isConfirmedSelect, "map.ids:", map.ids )

      if (revert) {
        // Cancel ants rect if the clicked image is the only one that
        // intersects rect, and the { x, y } point is outside its
        // bounding rect
        antRect = null
        map.ids = []

      } else {
        antRect = union(map.rects)
      }

      if (valuesMatch(antRect, this.state.antRect)) {
        // No update needed, even if the mouse / touch has moved
      } else {
        this._previewSelection(isSelect, map.ids, activeIds)
        this.setState({ antRect })
      }
    }

    const drop = () => {
      setTrackedEvents(cancel)
      this._updateSelection()
    }

    const cancel = setTrackedEvents({ event, drag, drop })
  }


  _previewSelection(isSelect, selectionChange, activeIds, rowNumber) {
    const changes = this.tracker(selectionChange)
    this._playSFX(changes, isSelect)

    // Add or remove the items that have changed since the action
    // started
    const selected  = isSelect
                      ? selectionChange.concat(this.selected)// true
                      : this.selected.filter( id => (        // false
                          selectionChange.indexOf(id) < 0
                        ))

    this.previewState = {
      selected
    , activeIds
    , rowNumber
    }

    // console.log("_previewSelection isSelect", isSelect, "selected:", selected, "activeRow:", this.state.activeRow, rowNumber)

    this.setState({ selected, activeIds })
  }


  _updateSelection() {
    let { selected, rowNumber, activeIds } = this.previewState

    // Reset activeRow and activeIds if the last element in what was
    // the activeRow is deselected
    const activeRow = selected.length
                    ? isNaN(rowNumber)
                      ? this.state.activeRow
                      : rowNumber
                    : -1
   activeIds = activeRow < 0
             ? []
             : activeIds
    // console.log("activeRow:", activeRow, "activeIds:", activeIds)

    this.setState({ activeRow, activeIds, antRect: null })
  }


  // <<< IMAGES AND MUSIC


  _prepareMusic() {
    const { simultaneous, music } = Theme.config.basic
    this.audioPlayer = new Background({ simultaneous, music })

    const checkForGameNotOver = () => {
      if (this.state.gameOver) {
        setTimeout(checkForGameNotOver, 100)

      } else if (this.state.music) {
        return this.audioPlayer.play()
      }
    }

    checkForGameNotOver()
  }


  _playSFX(changes, isSelect) {
    if (!this.state.sfx) {
      return
    }

    const random = Theme.config.random.sounds
    let type = isSelect ? "select" : "reject"
    changes.plus.forEach( id => this.pool.playSFX(id, type, random) )
    type = isSelect ? "reject" : "select"
    changes.minus.forEach( id => this.pool.playSFX(id, type, random) )
  }


  _playSound(gameOver, player, pass) {
    if (pass || !this.state.sfx) {
      return
    }

    const sound = gameOver
                ? this.state.vsAI
                  ? player
                    ? this.state.noHints
                      ? "ace"  // the human beat the AI with no help
                      : "best"// the human beat the AI
                    : "lose" // the human lost against the AI
                  : "win"   // one of the human players won
                : "play"   // the game is not over
    const file = Theme.config.basic[sound]
    this.pool.play(file)
   }


  _getBackgroundImage(){
    const images = Theme.config.basic.backgrounds

    // Take random item from near beginning and put it at the end
    let index = images.length
    if (!index) {
      return ""
    }

    index = Math.floor(Math.random() * index / 2 )

    const background = images.splice(index, 1)[0]
    images.push(background)

    return background.url
  }

  // <<< SETUP

  _getAssetsByRow(random) {
    // There may be:
    // * only one image (which should be in basic)
    // * an image in every slot in basic and rows -two
    //   to -four
    // * an image in only certain slots of rows -two to -four
    // * extra images that can be used
    //
    // For each cell, we may have:
    // * an image
    // * a sound effect
    // * an animGIF or sprite image to use for the disappearance
    // * an "empty space" image
    //
    // Returns an array of 16 elements with the format:
    // [ [ { image: <url>
    //     , select: <url>
    //     , reject: <url>
    //     }
    //   ]
    // , [ + 3 such items for row 2 ]
    // , [ + 5 such items for row 3 ]
    // , [ + 7 such items for row 4 ]
    // ]

    const assetsByRow = []

    if (random.single) {
      const unique = this._getRowData("row1")[0]
      // TODO

    }  else if (!random.order) {
      // Two possible cases to possible cases to check for:
      // 1. Only the default assets are provided
      // 2. Images are provided for all 16 cells
      // If neither of these cases are true, then
      // * Use whatever assets are available
      // * Repeat as necessary to fill up the slots
      // * Post a warning message in the Console

      assetsByRow.push(this._getRowData("row1"))
      assetsByRow.push(this._getRowData("row2"))
      assetsByRow.push(this._getRowData("row3"))
      assetsByRow.push(this._getRowData("row4"))

      // TODO: Ensure that all elements have a sound

    } else {
      // * Create an array of all the assets available
      // * Use the default select and reject assets wherever
      //   no such assets are provided for a particular image
      // * Distribute the elements of the array at random among
      //   the 4 rows

      let available = []
        .concat(this._getRowData("row1"))
        .concat(this._getRowData("row2"))
        .concat(this._getRowData("row3"))
        .concat(this._getRowData("row4"))

      if (random.useExtras) {
        available = available.concat(this._getRowData("extras"))
      }

      shuffle(available)

      assetsByRow.unshift(available.slice(9, 16))
      assetsByRow.unshift(available.slice(4, 9))
      assetsByRow.unshift(available.slice(1, 4))
      assetsByRow.unshift(available.slice(0, 1))
    }

    this._ensureRowsAreFullyPopulated(assetsByRow)
    this._ensureCellsHaveEnoughResources(assetsByRow)

    return assetsByRow
  }


  _getRowData(rowKey) { // "rowN" | ... | "extras"
    const row_data = []
    const data = Theme.config.counters[rowKey]
    const count = data.length

    // console.log("rowdata", data)

    data.forEach((cellData, index) => {
      const keys =  Object.keys(this.resources)
      const cell = this._getCell(rowKey, count, cellData, index)

      row_data.push(cell)

      keys.forEach( key => {
        if (cellData[key]) {
          this.resources[key].push(cellData[key])
        }     
      })
    })

    return row_data
  }


  _getCell(rowKey, count, cellData, index) {
    const cellName = rowKey + "-cell" + index
    const padding = randomPadding()
    const top = parseFloat(padding.split(" ")[0])

    let cell = {
      name: cellName
    , theme: {
        rotation: randomRotation() // may be 0° + no shadow
      , padding:  randomPadding()  // may be 0
      , spacing:  randomPadding(count, index, top)
      , equal:    randomPadding(1, index, top)
      }
    , ...cellData
    }

    return cell
  }


  _ensureRowsAreFullyPopulated(assetsByRow) {
    const expected = [1,3,5,7]
    const actual = assetsByRow.map( rowData => {
      return rowData.length
    })

    const availableResources = Object.keys(this.resources).filter(
      key => this.resources[key].length
    )

    if (availableResources.indexOf("image") < 0) {
      // No images are defined. Nothing will appear in the Play Area.
      // This situation needs human intervention
      return
    }

    const getRandomCellData = () => {
      const data = {}

      availableResources.forEach( key => {
        data[key] = getRandomFromArray(this.resources[key])
      })

      return data
    }

    expected.forEach((count, index) => {
      const row = assetsByRow[index]
      const rowKey = "row" + (index + 1) // row count starts at 1
      let ii = actual[index]
      let cellData,
          cell

      if (count - ii) {
        for ( ; ii < count; ii += 1 ) {
          cellData = getRandomCellData()
          cell = this._getCell(rowKey, count, cellData, ii)
          row.push(cell)
        }
      }
    })
  }


  _ensureCellsHaveEnoughResources(assetsByRow) {
    const items = ["image", "select", "reject"]

    assetsByRow.forEach( row => {
      row.forEach( cellData => {
        items.forEach( item => {
          if (!cellData[item]) {
            cellData[item] = getRandomFromArray(this.resources[item])
          }
        })
      })
    })
  }


  // <<< BUTTON NAMES

  _getStringLUT(stringMap) {
    const keys = Object.keys(stringMap)
    const LUT  = {}

    keys.forEach( key => {
      LUT[stringMap[key]] = key
    })

    return LUT
  }


  // <<< BUTTON ACTIONS

  _press(target) {
  }


  _startNewGame(vsAI) {
    this.setUpPieces()
    this._setRowMap() // cell.names have changed
    const { hints, steps, fail, groups } = this.state
    const assets = JSON.parse(JSON.stringify(this.assets))
    const options = { vsAI, hints, steps, fail, assets, groups }
    const { state, restore } = this.setUp.get(options)  

    // console.log(state)
    // console.log(restore)

    this.setState( state )  
    this.restore = restore
    if (vsAI) {
      this.ai.restore( this.restore.gameState )
    }
  }


  _setRowMap() {
    this.rowMap = {}

    this.assets.forEach((row, index) => {
      row.forEach(({ name }) => {
        this.rowMap[name] = index
      })
    })
  }


  killContextMenu(event) {
    if (event) {
      event.preventDefault()
      return false
    }

    const images = [].slice.call(document.querySelectorAll("img"))
      images.forEach( image => {
        image.oncontextmenu = this.killContextMenu
      }
    )
  }


  undo(event) {
    this.setState({
      removed: this.restore.removed
    , winning: false
    , fail: true
    })
    this.assets = JSON.parse(JSON.stringify(this.restore.assets))
    this.ai.restore( this.restore.gameState )

    // console.log(this.assets)
  }


  menuCallback(action) {
    // console.log("menuCallback", "action:", action)

    switch (action) {
      case "restart":
        this.showTips([])
        return this.setState({
          gameOver: true
        , removed: []
        , selected: []
        , fail: 0
        })

      case "music":
      case "sfx":
        this._toggleSound(action)
        // Fall through...
      case "credits":
       this.setState({
          [action]: !this.state[action]
        })
        return
    }

    // Otherwise toggle hint
    this.setState( action )
    this.storage.setHints(action)

    if (this.state.vsAI && !this.state.gameOver) {
      // Remove win privileges if the player asks for hints
      const type = Object.keys(action)[0] //undo, steps, tips, groups
      const state = action[type]
      let noHints = this.state.noHints

      if (state && noHints) {
        switch (type) {
          case "hints":
            noHints = !( this.state.undo
                      || this.state.steps
                      || this.state.tips
                      || this.state.groups
                       )
          break
          default:
            noHints = false
        }
        this.setState({ noHints })
      }
      // console.log("noHints:", noHints)
    }
  }


  _toggleSound(action) {
    const newState = !this.state[action]
    this.storage.setAudio(action, newState)

    if (action === "music") {
      if (newState) {
        this.audioPlayer.play()
      } else {
        this.audioPlayer.pause()
      }
    }
  }


  setLevel(event) {
    const rect = event.target.getBoundingClientRect()
    const horizontal = rect.width > rect.height
    let timeout
    let lastX
      , lastY

    const drag = (event) => {
      if (timeout) {
        return
      } else {
        timeout = setTimeout(() => {
           update(event);timeout = 0
        }, 250)
        update(event)
      }
    }


    const drop = (event) => {
      update(event)
      setTrackedEvents(cancel)
    }


    const update = (event) => {
      const { x, y } = getPageXY(event)
      if (x === undefined) {
        return
      } else if (x === lastX && y === lastY) {
        return
      }

      lastX = x
      lastY = y

      const ratio = (
        horizontal
        ? (x - window.scrollX - rect.x) / rect.width
        : (rect.bottom - y + window.scrollY) / rect.height
      )

      const level = Math.round(ratio * levels.length)
      this.setUp.setLevel(level)
      // this.setState({ level })

      this.playAI()
    }


    const cancel = setTrackedEvents({ event, drag, drop })
    update(event)
  }


  render() {
    // console.log("Game gameOver:", this.state.gameOver)
    return (
      <Container
        id="Container"
      >
        <PlayArea
          id="PlayArea"
          background={this.background}
        >
          <div
            className="background"
          ></div>
          <Board
            action={this.startDrag}
            setLevel={this.setLevel}
            rows={this.assets}
            gameState={this.state}
            // { selected, removed, activeIds, dragIds, gameOver }
          />

          <Level
            steps={ this.state.steps
                 && this.state.hints
                 && this.state.vsAI
                  }
            level={this.state.level + 1}
            action={this.setLevel}
          />

          <Ants
            rect={this.state.antRect}
          />

          <Overlay
            TextAnimator={this.TextAnimator}
            gameState={this.state}
          />
        </PlayArea>

        <StyledButtons
          id="Buttons"
        >
          <Button
            key="left"
            side="left"
            gameState={this.state}
            buttonDown={this.buttonDown.bind(this, "left")}
          />
          <Checkbox
            checked={this.state.showRules}
            onChange={this.toggleRules}
            disabled={!this.state.unlocked}
          />
          <Button
            key="right"
            side="right"
            gameState={this.state}
            buttonDown={this.buttonDown.bind(this, "right")}
          />
        </StyledButtons>

        <Menu
          callback={this.menuCallback}
          checkList={this.storage.get("hints")}
          gameState={this.state}
        />
      </Container>
    )
  }
}


export default Game;